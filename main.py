# Стек — абстрактный тип данных, представляющий список элементов, организованных по принципу LIFO
# (англ. last in — first out, «последним пришёл — первым вышел»).
# Чаще всего принцип работы стека сравнивают со стопкой тарелок: чтобы взять вторую сверху,
# нужно снять верхнюю. Или с магазином в огнестрельном оружии: стрельба начнётся с патрона, заряженного последним.
#
# Нужно реализовать класс Stack со следующими методами:
# is_empty — проверка стека на пустоту. Метод возвращает True или False;
# push — добавляет новый элемент на вершину стека. Метод ничего не возвращает;
# pop — удаляет верхний элемент стека. Стек изменяется. Метод возвращает верхний элемент стека;
# peek — возвращает верхний элемент стека, но не удаляет его. Стек не меняется;
# size — возвращает количество элементов в стеке.

class Stack:

    def __init__(self):
        self.list = list()

    def is_empty(self):
        if len(self.list) == 0:
            return True
        else:
            return False

    def push(self,x):
        self.list.append(x)

    def pop(self):
        return self.list.pop()

    def peek(self):
        return self.list[-1]

    def size(self):
        return len(self.list)




# Используя стек из задания 1, решите задачу на проверку сбалансированности скобок.
# Сбалансированность скобок означает, что каждый открывающий символ имеет соответствующий ему закрывающий,
# и пары скобок правильно вложены друг в друга.
# Пример сбалансированных последовательностей скобок:
#
# (((([{}]))))
# [([])((([[[]]])))]{()}
# {{[()]}}
# Несбалансированные последовательности:
#
# }{}
# {{[(])]}}
# [[{())}]
# Программа ожидает на вход строку со скобками. На выход сообщение:
# «Сбалансированно», если строка корректная, и «Несбалансированно», если строка составлена неверно.


brackets = {
	'(': ')',
	'{': '}',
	'[': ']'
}

base_string = input('Введите строку со скобками ')
stack = Stack()
balanced = True
for element in base_string:
	if element in brackets.keys():
		stack.push(element)
	elif element in brackets.values():
		if not stack.is_empty():
			expected_element = brackets[stack.pop()]
			if expected_element != element:
				balanced = False
				break
		else:
			balanced = False
			break
if balanced:
	print('Сбалансировано')
else:
	print('Несбалансировано')

print(stack.push(element))

